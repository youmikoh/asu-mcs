\documentclass[letterpaper]{article}
\usepackage{aaai20}
\usepackage{times}
\usepackage{helvet}
\usepackage{courier}
\usepackage[hyphens]{url}
\usepackage{graphicx}
\urlstyle{rm}
\def\UrlFont{\rm}
\usepackage{graphicx}
\frenchspacing
\setlength{\pdfpagewidth}{8.5in}
\setlength{\pdfpageheight}{11in}


% command
% \newcommand{\ct}[1]{\texttt{#1}}
\newcommand{\ct}[1]{\texttt{\textbf{#1}}}


\pdfinfo{
    /Title (CSE579: Automated Warehouse Scenario - Project Milestone 3)
    /Author (Youmi Koh)
}

\title{
    CSE579: Project Milestone 3\\
    Automated Warehouse Scenario\\
    Progress Report}
\author{
    Written by Youmi Koh \\
    Arizona State University \\
    ykoh7@asu.edu
}
\date{June 21, 2023}

\begin{document}

\maketitle


\begin{abstract}
This report outlines progress made towards representing the Automated Warehouse Scenario using answer set programming, and motivation behind why certain constraint representations were chosen over others. It highlights challenges with grounding, conflicting preconditions and effects, and the approach taken to address these problems.
\end{abstract}

\section{Problem Statement}

\noindent The Automated Warehouse Scenario describes a warehouse environment where a set of robots are tasked with delivering products from inventory stock shelves to designated order picking stations for fulfillment. Orders may include multiple products, and there are various restrictions on to how the robots can operate. The objective is to devise a plan to fulfill all orders in as few steps as possible.

\section{Scenario Description}

The scenario starts at time \ct{T=0}. The components of the warehouse scenario can be partitioned into: those that are static and unchanging over time, and others that represent the state of the warehouse at a given time. The latter is termed \emph{fluents}, and can be affected by both time and actions.

\subsection{Static Objects}

Inside the warehouse, the floor is represented in a grid format. Every cell on the grid floor is expressed as \ct{node(N,(X,Y))} where \ct{(X,Y)} are the cell coordinates, and symbolize a location of the warehouse floor where physical objects can be positioned. Certain cells of the warehouse floor are designated as highways and order picking stations, expressed as \ct{highway(H,(X,Y))} and \ct{pickingStation(PS,(X,Y))} respectively.

\subsection{Fluents and Actions}

All robots \ct{R} and shelves \ct{S} are located at a node, and their position at time \ct{T} is expressed as \ct{robotAt(R,(X,Y),T)} and \ct{shelfAt(S,(X,Y),T)} respectively. Products can be stocked in multiple shelves, and inventory levels are expressed as \ct{inventoryOn(P,S,Q,T)} where \ct{Q} denotes the quantity of product \ct{P} stocked on shelf \ct{S} at time \ct{T}.

Robots are mobile, and can move in 4 cardinal directions. The movement of robot \ct{R} at time \ct{T} is expressed as \ct{move(R,(DX,DY),T)} where \ct{(DX,DY)} is a directional unit vector. Robots can pick up and put down shelves, which enables them to carry shelves as they move and relocate the shelf at a new position. The action of a robot picking up a shelf is expressed as \ct{pickup(R,S,T)}, and the action of a robot putting down a shelf is expressed as \ct{putdown(R,S,T)}. The boolean value of \ct{B} in \ct{carrying(B,R,S,T)} is set to \emph{true} when robot \ct{R} is carrying shelf \ct{S}, and \emph{false} otherwise.

The warehouse must fulfill all orders \ct{O} at its designated picking station. Orders are composed of multiple line items that state the number of units of a product \ct{P}, expressed as \ct{lineItem(O,P,U,T)} where \ct{U} denotes the remaining number of fulfillable units of product \ct{P} at time \ct{T}. The action of a robot delivering \ct{D} units of a given order's line item is expressed as \ct{deliver(R,O,P,D,T)}.

\subsection{Rules and Constraints}

Starting with the domain independent axioms, we use choice rules to set constraints for each fluent to be initially exogenous, inertial, and ensure the existence and uniqueness of their value. Although initially exogenous, when a starting instance is provided, fluents adopt the initial state as defined in each instance. Actions are also declared as exogenous using choice rules. The following is an example of the \ct{robotAt} fluent and \ct{move} action.

\begin{quote}\begin{scriptsize}\begin{verbatim}
{robotAt(R,(X,Y),0)}=1 :- robot(R).
{robotAt(S,(X,Y),T+1)} :- robotAt(S,(X,Y),T), T=0..m-1.
:- not {robotAt(R,(X,Y),T)}=1, robot(R), T=0..m.
robotAt(R,(X,Y),0) :- % initialize with instance state
    init(object(robot,R),value(at,pair(X,Y))).
{move(R,(DX,DY),T)} :-
    robot(R), DX=-1..1, DY=-1..1, T=0..m.
\end{verbatim}\end{scriptsize}\end{quote}

The  \ct{move}  action directly affects \ct{robotAt} since it changes the location of the robot. This can be expressed recursively as follows:
\begin{quote}\begin{scriptsize}\begin{verbatim}
robotAt(R,(X+DX,Y+DY),T+1) :-
    move(R,(DX,DY),T), robotAt(R,(X,Y),T), T=0..m-1.
\end{verbatim}\end{scriptsize}\end{quote}

We also declare precondition constraints to restrict the robot from moving diagonally, and disallow moving to a node that is occupied by a robot. Note this covers the case where two robots swap positions, since no robot can move to a node \emph{currently} occupied by another robot, regardless of whether it will move in the same time step.
In the move's effect constraints, we ensure that all robots must always be on a valid node (i.e. lands on a valid node post-move) and that no 2 robots can occupy the same node at the same time.

\begin{quote}\begin{scriptsize}\begin{verbatim}
:- move(R,(DX,DY),T), |DX|=|DY|, T=0..m-1.
:- move(R,(DX,DY),T), robotAt(R,(X,Y),T),
    robotAt(RR,(X+DX,Y+DY),T), T=0..m-1.
:- robotAt(R,(X,Y),T), not node(_,(X,Y)).
:- 2{robotAt(R,(X,Y),T)}, node(N,(X,Y)), T=0..m.
\end{verbatim}\end{scriptsize}\end{quote}

Since shelves are relocated by robots, their location is declared in terms of the robot's location and the \ct{carrying}  fluent state. Similarly to the robots, we also limit two shelves from occupying the same node at the same time.

\begin{quote}\begin{scriptsize}\begin{verbatim}
shelfAt(S,(X+DX,Y+DY),T+1) :-
    move(R,(DX,DY),T), carrying(t,R,S,T),
    robotAt(R,(X,Y),T), shelfAt(S,(X,Y),T), T=0..m-1.
:- 2{shelfAt(S,(X,Y),T)}, node(_,(X,Y)), T=0..m.
\end{verbatim}\end{scriptsize}\end{quote}

The \ct{carrying} fluent is directly affected by the \ct{pickup} and \ct{putdown} actions. We add precondition constraints to ensure robots can only pick up shelves occupying the same node, and must not already be carrying any other shelf. The put down action can only be performed if the robot is carrying a shelf, and must not occur on a highway node.

\begin{quote}\begin{scriptsize}\begin{verbatim}
carrying(f,R,S,0) :- robot(R), shelf(S).
carrying(t,R,S,T+1) :- pickup(R,S,T).
carrying(f,R,S,T+1) :- putdown(R,S,T), carrying(t,R,S,T).
:- pickup(R,S,T),
    robotAt(R,(X,Y),T), not shelfAt(S,(X,Y),T).
:- pickup(R,S,T), 1{carrying(t,R,SS,T)}.
:- putdown(R,S,T), carrying(f,R,S,T).
:- putdown(R,S,T),
    robotAt(R,(X,Y),T), highway(H,(X,Y)).
\end{verbatim}\end{scriptsize}\end{quote}

\ct{inventoryOn} and \ct{lineItem} fluents are directly affected by the \ct{deliver} action, and declared recursively. Precondition constraints are added to ensure that the robot must be carrying the shelf containing the product, and that the order's delivery is occurring at the designated picking station. To prevent inventory quantity and line item units from falling below 0, we restrict the number of units delivered.

\begin{quote}\begin{scriptsize}\begin{verbatim}
inventoryOn(P,S,Q-D,T+1) :-
    deliver(R,O,P,D,T), inventoryOn(P,S,Q,T).
lineItem(O,P,U-D,T+1) :-
    deliver(R,O,P,D,T), lineItem(O,P,U,T).
:- deliver(R,O,P,D,T),
    product(P,S,_), carrying(f,R,S,T).
:- deliver(R,O,P,D,T), order(O,PS),
    robotAt(R,(X,Y),T), not pickingStation(PS,(X,Y)).
:- deliver(R,O,P,U,T),
    inventoryOn(P,S,Q,T), lineItem(O,P,U,T), U>Q.
:- deliver(R,O,P,Q,T), inventoryOn(P,S,Q,T),
    lineItem(O,P,U,T), Q>U.
\end{verbatim}\end{scriptsize}\end{quote}


\section{Challenges with Representing the Scenario}

\subsection{Grounding}

First, I attempted to represent the scenario with only the fluents and actions introduced in the original description. Although most of the fluents were similarly represented to the previous section, there were no ground terms declared. For example, instead of having a ground term \ct{robot(R)} and the fluent \ct{robotAt(R,(X,Y),T)}, the entire robot object was declared as \ct{robot(R,(X,Y),T)}. As constraints were written, the program became unnecessarily complex. Many unused variables were introduced in the rules, and naively I tried to resolve this by using anonymous variables. It became increasingly difficult to debug and understand the program, and given that clingo attempts to ground all terms, it wasn't obvious to me that the lack of ground terms was the root cause of the problem.

While reviewing the live sessions in preparation for the midterm, the "Methodology of ASP in Clingo" slide highlights the first part as generating a search space of potential solutions, which made me realize that my attempts without ground terms was creating a near unlimited search space \cite{Altunkaya2023}. With this in mind, I factored out the ground terms which helped to simplify all rules and constraints. At one point, the below was how I was declaring the exogenous nature of the \ct{deliver} action.

\begin{quote}\begin{scriptsize}\begin{verbatim}
{deliver(R,O,P,U,T)} :-
    robot(R,(X,Y),T), order(O,P,U,PS,T),
    pickingStation(PS,(X,Y)), T=1..m-1.
\end{verbatim}\end{scriptsize}\end{quote}

The same is now expressed as the below, which leverages the use of local variables to further limit the starting search space.

\begin{quote}\begin{scriptsize}\begin{verbatim}
{deliver(R,O,P,D,T): order(O,P,U), D=1..U} :-
    robot(R), T=0..m.
\end{verbatim}\end{scriptsize}\end{quote}


\subsection{Balancing Satisfiability and Optimality}

I started with very few necessary rules to generate a reasonable search space, and as constraints were added to remove undesirable behaviour, the program often became unsatisfiable. In these cases, I relaxed the new constraint as much as possible to meet satisfability then worked with small instances to detect any states in violation of the scenario conditions. Declaring an appropriate objective function to fulfill all orders while minimizing the time steps has also been a challenge.

\section{Conclusion}

At this current state, I am testing the program with the sample example in the original scenario description, and comparing my results to the featured optimal model. With an objective function maximizing for number of deliver actions, the program is able to fulfill all orders in less time steps than the featured optimal model. There are likely certain actions and states that violate the original conditions, and I will continue to refine the constraints to ensure that the program is able to generate plans that are both satisfiable and optimal.

\nocite{erdem2021asp}
\nocite{DBLP:journals/aim/KaufmannLPS16}

\begin{quote}
    \begin{small}
        \bibliographystyle{aaai}
        \bibliography{references}
    \end{small}
\end{quote}
\end{document}
